# vim: ft=sh

# For platform-specific conditions
OS=`uname`

# Don't put duplicate lines into history, ignore commands w/ initial space
HISTCONTROL=ignoredup:ignorespace

if [ -f $HOME/.shrc ]; then
  source $HOME/.shrc
fi

# Bash options: {{{
# Auto-correct typos
shopt -s cdspell
# Check hash before executing
shopt -s checkhash
# Check window size after each command, and update $LINES and $COLUMNS
shopt -s checkwinsize
# Save all lines of multiline commands
shopt -s cmdhist
# Include filenames that begin with '.' in filename expansion
shopt -s dotglob
# Append to history list. Allow editing of history substitution in readline
# buffer
shopt -s histappend histreedit histverify
# Don't search path for completions when on an empty line
shopt -s no_empty_cmd_completion
# Case insensitive filename matching
shopt -s nocaseglob
# Not supported in ancient OS X version of bash
if [ "${BASH_VERSION%.*}" \> "4.2" ]; then
  # CD into dir as command
  shopt -s autocd
  # Warn about stopped jobs before exiting
  shopt -s checkjobs
  # Replace directory names when doing tab completion
  shopt -s direxpand
  # Spell check on directory names
  shopt -s dirspell
  # Use ** for nice filename matching
  shopt -s globstar
fi
# }}}

# Simple prompt user@host:pwd $
BASE_PROMPT="\[\e[31m\]\u@\h\[\e[m\]:\[\e[33m\]\w\[\e[m\]"
JOB_COUNT="\[\e[1;34m\][\j]\[\e[m\] "
# Add job count if non-zero
export PROMPT_COMMAND='HAS_JOBS=$(jobs -p) '
PS1="$BASE_PROMPT ""\${HAS_JOBS:+$JOB_COUNT}"

if [ -f /etc/bash_completion.d/git-prompt ]; then
  # Show colored hint about dirty state
  export GIT_PS1_SHOWCOLORHINTS=1
  # Show staged/unstaged changes marker
  export GIT_PS1_SHOWDIRTYSTATE=1
  # Show a $ next to branch name if something stashed
  export GIT_PS1_SHOWSTASHSTATE=1
  # Note untracked files
  export GIT_PS1_SHOWUNTRACKEDFILES=1
  source /etc/bash_completion.d/git-prompt
  export PROMPT_COMMAND="HAS_JOBS=\`jobs -p\`; __git_ps1 \"$BASE_PROMPT\" \" \${HAS_JOBS:+$JOB_COUNT }\""
fi

# FZF keybindings
if [ -f ~/.fzf.bash ]; then
  source ~/.fzf.bash
fi

# Load OS-specific files
if [[ $OS == "Darwin" ]]; then
  if [ -f $HOME/.bashrc.osx ]; then
    source $HOME/.bashrc.osx
  fi
elif [[ $OS == "Linux" ]]; then
  if [ -f $HOME/.bashrc.linux ]; then
    source $HOME/.bashrc.linux
  fi
fi

# Load local file if present
if [ -f $HOME/.bashrc.local ]; then
  source $HOME/.bashrc.local
fi
